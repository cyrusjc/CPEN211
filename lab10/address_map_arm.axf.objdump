
C:/Users/Cyrus/Desktop/CPEN211/lab10/address_map_arm.axf:     file format elf32-littlearm


Disassembly of section .vectors:

00000000 <__cs3_interrupt_vector>:
   0:	ea000053 	b	154 <_start>
   4:	ea000081 	b	210 <SERVICE_UND>
   8:	ea000081 	b	214 <SERVICE_SVC>
   c:	ea000082 	b	21c <SERVICE_ABT_INST>
  10:	ea000080 	b	218 <SERVICE_ABT_DATA>
  14:	00000000 	.word	0x00000000
  18:	ea000080 	b	220 <SERVICE_IRQ>
  1c:	ea000102 	b	42c <SERVICE_FIQ>

Disassembly of section .text:

00000040 <CONFIG_GIC>:
/* 
 * Configure the Generic Interrupt Controller (GIC)
*/
				.global	CONFIG_GIC
CONFIG_GIC:
				PUSH		{LR}
  40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    			/* To configure the FPGA KEYS interrupt (ID 73):
				 *	1. set the target to cpu0 in the ICDIPTRn register
				 *	2. enable the interrupt in the ICDISERn register */
				/* CONFIG_INTERRUPT (int_ID (R0), CPU_target (R1)); */
    			MOV		R0, #73					// KEY port (interrupt ID = 73)
  44:	e3a00049 	mov	r0, #73	; 0x49
    			MOV		R1, #1					// this field is a bit-mask; bit 0 targets cpu0
  48:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
  4c:	eb00000d 	bl	88 <CONFIG_INTERRUPT>
				
    			MOV		R0, #80					// ID 80
  50:	e3a00050 	mov	r0, #80	; 0x50
    			MOV		R1, #1					//
  54:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
  58:	eb00000a 	bl	88 <CONFIG_INTERRUPT>
				
				
	    		MOV		R0, #29					//ID29
  5c:	e3a0001d 	mov	r0, #29
    			MOV		R1, #1					// 
  60:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
  64:	eb000007 	bl	88 <CONFIG_INTERRUPT>

				/* configure the GIC CPU interface */
    			LDR		R0, =MPCORE_GIC_CPUIF	// base address of CPU interface
  68:	e59f0060 	ldr	r0, [pc, #96]	; d0 <HPS_WATCHDOG1_IRQ+0x4>
    			/* Set Interrupt Priority Mask Register (ICCPMR) */
    			LDR		R1, =0xFFFF 			// enable interrupts of all priorities levels
  6c:	e59f1060 	ldr	r1, [pc, #96]	; d4 <HPS_WATCHDOG1_IRQ+0x8>
    			STR		R1, [R0, #ICCPMR]
  70:	e5801004 	str	r1, [r0, #4]
    			/* Set the enable bit in the CPU Interface Control Register (ICCICR). This bit
				 * allows interrupts to be forwarded to the CPU(s) */
    			MOV		R1, #1
  74:	e3a01001 	mov	r1, #1
    			STR		R1, [R0]
  78:	e5801000 	str	r1, [r0]
    
    			/* Set the enable bit in the Distributor Control Register (ICDDCR). This bit
				 * allows the distributor to forward interrupts to the CPU interface(s) */
    			LDR		R0, =MPCORE_GIC_DIST
  7c:	e59f0054 	ldr	r0, [pc, #84]	; d8 <HPS_WATCHDOG1_IRQ+0xc>
    			STR		R1, [R0]    
  80:	e5801000 	str	r1, [r0]
    
    			POP     	{PC}
  84:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00000088 <CONFIG_INTERRUPT>:
 * other registers in the GIC
 * Arguments: R0 = interrupt ID, N
 *            R1 = CPU target
*/
CONFIG_INTERRUPT:
    			PUSH		{R4-R5, LR}
  88:	e92d4030 	push	{r4, r5, lr}
    
    			/* Configure Interrupt Set-Enable Registers (ICDISERn). 
				 * reg_offset = (integer_div(N / 32) * 4
				 * value = 1 << (N mod 32) */
    			LSR		R4, R0, #3							// calculate reg_offset
  8c:	e1a041a0 	lsr	r4, r0, #3
    			BIC		R4, R4, #3							// R4 = reg_offset
  90:	e3c44003 	bic	r4, r4, #3
				LDR		R2, =MPCORE_GIC_DIST+ICDISER
  94:	e59f2040 	ldr	r2, [pc, #64]	; dc <HPS_WATCHDOG1_IRQ+0x10>
				ADD		R4, R2, R4							// R4 = address of ICDISER
  98:	e0824004 	add	r4, r2, r4
    
    			AND		R2, R0, #0x1F   					// N mod 32
  9c:	e200201f 	and	r2, r0, #31
				MOV		R5, #1								// enable
  a0:	e3a05001 	mov	r5, #1
    			LSL		R2, R5, R2							// R2 = value
  a4:	e1a02215 	lsl	r2, r5, r2

				/* now that we have the register address (R4) and value (R2), we need to set the
				 * correct bit in the GIC register */
    			LDR		R3, [R4]								// read current register value
  a8:	e5943000 	ldr	r3, [r4]
    			ORR		R3, R3, R2							// set the enable bit
  ac:	e1833002 	orr	r3, r3, r2
    			STR		R3, [R4]								// store the new register value
  b0:	e5843000 	str	r3, [r4]

    			/* Configure Interrupt Processor Targets Register (ICDIPTRn)
     			 * reg_offset = integer_div(N / 4) * 4
     			 * index = N mod 4 */
    			BIC		R4, R0, #3							// R4 = reg_offset
  b4:	e3c04003 	bic	r4, r0, #3
				LDR		R2, =MPCORE_GIC_DIST+ICDIPTR
  b8:	e59f2020 	ldr	r2, [pc, #32]	; e0 <HPS_WATCHDOG1_IRQ+0x14>
				ADD		R4, R2, R4							// R4 = word address of ICDIPTR
  bc:	e0824004 	add	r4, r2, r4
    			AND		R2, R0, #0x3						// N mod 4
  c0:	e2002003 	and	r2, r0, #3
				ADD		R4, R2, R4							// R4 = byte address in ICDIPTR
  c4:	e0824004 	add	r4, r2, r4

				/* now that we have the register address (R4) and value (R2), write to (only)
				 * the appropriate byte */
				STRB		R1, [R4]
  c8:	e5c41000 	strb	r1, [r4]
    
    			POP		{R4-R5, PC}
  cc:	e8bd8030 	pop	{r4, r5, pc}
  d0:	fffec100 	.word	0xfffec100
  d4:	0000ffff 	.word	0x0000ffff
  d8:	fffed000 	.word	0xfffed000
  dc:	fffed100 	.word	0xfffed100
  e0:	fffed800 	.word	0xfffed800

000000e4 <KEY_ISR>:
 * This routine checks which KEY has been pressed. It writes to HEX0
 ***************************************************************************************/
				
				.global	KEY_ISR
KEY_ISR:		
				LDR		R0, =KEY_BASE			// base address of pushbutton KEY port
  e4:	e59f0060 	ldr	r0, [pc, #96]	; 14c <END_KEY_ISR+0x4>
				LDR		R1, [R0, #0xC]			// read edge capture register
  e8:	e590100c 	ldr	r1, [r0, #12]
				MOV		R2, #0xF
  ec:	e3a0200f 	mov	r2, #15
				STR		R2, [R0, #0xC]			// clear the interrupt
  f0:	e580200c 	str	r2, [r0, #12]

				LDR		R0, =HEX3_HEX0_BASE	// based address of HEX display
  f4:	e59f0054 	ldr	r0, [pc, #84]	; 150 <END_KEY_ISR+0x8>

000000f8 <CHECK_KEY0>:
CHECK_KEY0:
				MOV		R3, #0x1
  f8:	e3a03001 	mov	r3, #1
				ANDS		R3, R3, R1				// check for KEY0
  fc:	e0133001 	ands	r3, r3, r1
				BEQ		CHECK_KEY1
 100:	0a000002 	beq	110 <CHECK_KEY1>
				MOV		R2, #0b00111111
 104:	e3a0203f 	mov	r2, #63	; 0x3f
				STR		R2, [R0]					// display "0"
 108:	e5802000 	str	r2, [r0]
				B			END_KEY_ISR
 10c:	ea00000d 	b	148 <END_KEY_ISR>

00000110 <CHECK_KEY1>:
CHECK_KEY1:
				MOV		R3, #0x2
 110:	e3a03002 	mov	r3, #2
				ANDS		R3, R3, R1				// check for KEY1
 114:	e0133001 	ands	r3, r3, r1
				BEQ		CHECK_KEY2
 118:	0a000002 	beq	128 <CHECK_KEY2>
				MOV		R2, #0b00000110
 11c:	e3a02006 	mov	r2, #6
				STR		R2, [R0]					// display "1"
 120:	e5802000 	str	r2, [r0]
				B			END_KEY_ISR
 124:	ea000007 	b	148 <END_KEY_ISR>

00000128 <CHECK_KEY2>:
CHECK_KEY2:
				MOV		R3, #0x4
 128:	e3a03004 	mov	r3, #4
				ANDS		R3, R3, R1				// check for KEY2
 12c:	e0133001 	ands	r3, r3, r1
				BEQ		IS_KEY3
 130:	0a000002 	beq	140 <IS_KEY3>
				MOV		R2, #0b01011011
 134:	e3a0205b 	mov	r2, #91	; 0x5b
				STR		R2, [R0]					// display "2"
 138:	e5802000 	str	r2, [r0]
				B			END_KEY_ISR
 13c:	ea000001 	b	148 <END_KEY_ISR>

00000140 <IS_KEY3>:
IS_KEY3:
				MOV		R2, #0b01001111
 140:	e3a0204f 	mov	r2, #79	; 0x4f
				STR		R2, [R0]					// display "3"
 144:	e5802000 	str	r2, [r0]

00000148 <END_KEY_ISR>:
END_KEY_ISR:
				BX			LR
 148:	e12fff1e 	bx	lr
 14c:	ff200050 	.word	0xff200050
 150:	ff200020 	.word	0xff200020

00000154 <_start>:

				.text
				.global	_start
_start:		
				/* Set up stack pointers for IRQ and SVC processor modes */
				MOV		R1, #0b11010010					// interrupts masked, MODE = IRQ
 154:	e3a010d2 	mov	r1, #210	; 0xd2
				MSR		CPSR_c, R1							// change to IRQ mode
 158:	e121f001 	msr	CPSR_c, r1
				LDR		SP, =A9_ONCHIP_END - 3			// set IRQ stack to top of A9 onchip memory
 15c:	e3e0d003 	mvn	sp, #3
				/* Change to SVC (supervisor) mode with interrupts disabled */
				MOV		R1, #0b11010011					// interrupts masked, MODE = SVC
 160:	e3a010d3 	mov	r1, #211	; 0xd3
				MSR		CPSR, R1								// change to supervisor mode
 164:	e129f001 	msr	CPSR_fc, r1
				LDR		SP, =DDR_END - 3					// set SVC stack to top of DDR3 memory
 168:	e3e0d10f 	mvn	sp, #-1073741821	; 0xc0000003

				BL			CONFIG_GIC							// configure the ARM generic interrupt controller
 16c:	ebffffb3 	bl	40 <CONFIG_GIC>

				// write to the pushbutton KEY interrupt mask register
				LDR		R0, =KEY_BASE						// pushbutton KEY base address
 170:	e59f0350 	ldr	r0, [pc, #848]	; 4c8 <PD_ARRAY+0x88>
				MOV		R1, #0xF								// set interrupt mask bits
 174:	e3a0100f 	mov	r1, #15
				STR		R1, [R0, #0x8]						// interrupt mask register is (base + 8)
 178:	e5801008 	str	r1, [r0, #8]

				// enable IRQ interrupts in the processor
				MOV		R0, #0b01010011					// IRQ unmasked, MODE = SVC
 17c:	e3a00053 	mov	r0, #83	; 0x53
				MSR		CPSR_c, R0
 180:	e121f000 	msr	CPSR_c, r0

				LDR		R0, =0xFFFEC600					//BASE ADDRESS OF TIMA
 184:	e59f0340 	ldr	r0, [pc, #832]	; 4cc <PD_ARRAY+0x8c>
				LDR 	R3, =100000000					//10000000x1/200x10^6 = .5
 188:	e59f3340 	ldr	r3, [pc, #832]	; 4d0 <__cs3_region_init_size_ram>
				STR 	R3, [R0]						
 18c:	e5803000 	str	r3, [r0]
				MOV		R1, #0b111						//SETTING ALL THAT STUFF TO 1
 190:	e3a01007 	mov	r1, #7
				STR		R1, [R0,#0x8]					//STORING IT TO ENABLE INTERUPT FROM TIMER
 194:	e5801008 	str	r1, [r0, #8]
				
				LDR		R0, =0xFF201000
 198:	e59f0334 	ldr	r0, [pc, #820]	; 4d4 <__cs3_region_init_size_ram+0x4>
				MOV		R1, #0b11
 19c:	e3a01003 	mov	r1, #3
				STR		R1, [R0,#0x8]		
 1a0:	e5801008 	str	r1, [r0, #8]

000001a4 <IDLE>:
				
				
IDLE:	
				LDR		R2, =CHAR_FLAG
 1a4:	e59f232c 	ldr	r2, [pc, #812]	; 4d8 <__cs3_region_init_size_ram+0x8>
				LDR		R3, [R2]
 1a8:	e5923000 	ldr	r3, [r2]
				CMP		R3, #1
 1ac:	e3530001 	cmp	r3, #1
				BEQ		IS_1
 1b0:	0a000000 	beq	1b8 <IS_1>
				B 		IDLE							// main program simply idles
 1b4:	eafffffa 	b	1a4 <IDLE>

000001b8 <IS_1>:
				
	IS_1:	
				LDR		R1, =CHAR_BUFFER
 1b8:	e59f131c 	ldr	r1, [pc, #796]	; 4dc <__cs3_region_init_size_ram+0xc>
				LDR		R0, [R1]
 1bc:	e5910000 	ldr	r0, [r1]
				/* from lecture slides ------------------------------------------*/
				LDR 	R1, =0xFF201000 					// JTAG UART base address
 1c0:	e59f130c 	ldr	r1, [pc, #780]	; 4d4 <__cs3_region_init_size_ram+0x4>
				LDR 	R2, [R1, #4] 						// read the JTAG UART control register
 1c4:	e5912004 	ldr	r2, [r1, #4]
				LDR 	R3, =0xFFFF
 1c8:	e59f3310 	ldr	r3, [pc, #784]	; 4e0 <__cs3_region_init_size_ram+0x10>
				ANDS	 R2, R2, R3 						// check for write space
 1cc:	e0122003 	ands	r2, r2, r3
				BEQ 	IDLE 								// if no space, ignore the character
 1d0:	0afffff3 	beq	1a4 <IDLE>
				STR 	R0, [R1] 							// send the character
 1d4:	e5810000 	str	r0, [r1]
				B		IDLE
 1d8:	eafffff1 	b	1a4 <IDLE>

000001dc <PROC1>:
		
PROC1:

				LDR		R9, =counter
 1dc:	e59f9300 	ldr	r9, [pc, #768]	; 4e4 <__cs3_region_init_size_ram+0x14>
				LDR 	R4, [R4]
 1e0:	e5944000 	ldr	r4, [r4]
				MOV 	R5, #0
 1e4:	e3a05000 	mov	r5, #0
				ADD 	R5, R5, #1
 1e8:	e2855001 	add	r5, r5, #1
				STR 	R5, [R9]
 1ec:	e5895000 	str	r5, [r9]
				
				LDR		R8, =LEDR_BASE		//R5 = base address of led
 1f0:	e59f82f0 	ldr	r8, [pc, #752]	; 4e8 <__cs3_region_init_size_ram+0x18>
				STR		R5, [R8]			//store data[0] into LED
 1f4:	e5885000 	str	r5, [r8]
				
				MOV 	R6, #0
 1f8:	e3a06000 	mov	r6, #0
				LDR		R7, =400000000
 1fc:	e59f72e8 	ldr	r7, [pc, #744]	; 4ec <__cs3_region_init_size_ram+0x1c>

00000200 <ADDLOOP>:
	ADDLOOP	:			
				ADD 	R6, R6, #1
 200:	e2866001 	add	r6, r6, #1
				CMP 	R6, R7
 204:	e1560007 	cmp	r6, r7
				BNE		ADDLOOP
 208:	1afffffc 	bne	200 <ADDLOOP>
				B		PROC1
 20c:	eafffff2 	b	1dc <PROC1>

00000210 <SERVICE_UND>:

/* Define the exception service routines */

/*--- Undefined instructions --------------------------------------------------*/
SERVICE_UND:
    			B SERVICE_UND 
 210:	eafffffe 	b	210 <SERVICE_UND>

00000214 <SERVICE_SVC>:
 
/*--- Software interrupts -----------------------------------------------------*/
SERVICE_SVC:			
    			B SERVICE_SVC 
 214:	eafffffe 	b	214 <SERVICE_SVC>

00000218 <SERVICE_ABT_DATA>:

/*--- Aborted data reads ------------------------------------------------------*/
SERVICE_ABT_DATA:
    			B SERVICE_ABT_DATA 
 218:	eafffffe 	b	218 <SERVICE_ABT_DATA>

0000021c <SERVICE_ABT_INST>:

/*--- Aborted instruction fetch -----------------------------------------------*/
SERVICE_ABT_INST:
    			B SERVICE_ABT_INST 
 21c:	eafffffe 	b	21c <SERVICE_ABT_INST>

00000220 <SERVICE_IRQ>:
 
/*--- IRQ ---------------------------------------------------------------------*/
SERVICE_IRQ:
    			PUSH		{R0-R7, LR}
 220:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
				
				/* PART 2 INTERUPT FROM TIMA--------------------------------*/
				SUB sp, sp, #12
 224:	e24dd00c 	sub	sp, sp, #12
				STR R8, [sp, #8]			//SAVING REGISTERS SO WE CAN SAVE IN THE FIRST ONE
 228:	e58d8008 	str	r8, [sp, #8]
				STR R5, [sp, #4]
 22c:	e58d5004 	str	r5, [sp, #4]
				STR R4, [sp, #0]	
 230:	e58d4000 	str	r4, [sp]
				
				LDR 	R8, =0xFFFEC100 	//Interuprt controller's base addr
 234:	e59f82b4 	ldr	r8, [pc, #692]	; 4f0 <__cs3_region_init_size_ram+0x20>
				LDR 	R5, [R8,#0xC]		//Determine source of interupt
 238:	e598500c 	ldr	r5, [r8, #12]
				CMP		R5, #29
 23c:	e355001d 	cmp	r5, #29
				BNE		NEXT
 240:	1a000068 	bne	3e8 <NEXT>
				
				MRS 	R8, SPSR
 244:	e14f8000 	mrs	r8, SPSR
				MOV		R4, #0b11010011					// interrupts masked, MODE = SVC
 248:	e3a040d3 	mov	r4, #211	; 0xd3
				MSR		CPSR, R4						// change to supervisor mode
 24c:	e129f004 	msr	CPSR_fc, r4
				
				LDR		R4, =CURRENT_PID
 250:	e59f429c 	ldr	r4, [pc, #668]	; 4f4 <__cs3_region_init_size_ram+0x24>
				LDR		R5, [R4]
 254:	e5945000 	ldr	r5, [r4]
				
				CMP 	R5, #0
 258:	e3550000 	cmp	r5, #0
				BNE		OTHER_PROGRAM
 25c:	1a000005 	bne	278 <OTHER_PROGRAM>
				BEQ		STACKSAVE1				// IF ITS ZERO, YOU GOTTA STORE ALL THAT R0-R15 TO PDARRAY[0]-PDARRAY- 17	
 260:	0a00000b 	beq	294 <STACKSAVE1>

00000264 <IRQ1>:
		IRQ1:
				MOV 	R4, #1
 264:	e3a04001 	mov	r4, #1
				LDR 	R5, =CURRENT_PID
 268:	e59f5284 	ldr	r5, [pc, #644]	; 4f4 <__cs3_region_init_size_ram+0x24>
				STR		R4, [R5]								//MAKING PID 1
 26c:	e5854000 	str	r4, [r5]
				B		LOADREG1
 270:	ea00001f 	b	2f4 <LOADREG1>
				B		NEXT
 274:	ea00005b 	b	3e8 <NEXT>

00000278 <OTHER_PROGRAM>:

	OTHER_PROGRAM:			
				CMP		R5, #1
 278:	e3550001 	cmp	r5, #1
				BEQ		STACKSAVE2
 27c:	0a00002e 	beq	33c <STACKSAVE2>

00000280 <IRQ2>:
		IRQ2:
				MOV 	R4, #0
 280:	e3a04000 	mov	r4, #0
				LDR 	R5, =CURRENT_PID
 284:	e59f5268 	ldr	r5, [pc, #616]	; 4f4 <__cs3_region_init_size_ram+0x24>
				STR		R4, [R5]								//MAKING PID 0
 288:	e5854000 	str	r4, [r5]
				B		LOADREG2
 28c:	ea000043 	b	3a0 <LOADREG2>
				B		NEXT
 290:	ea000054 	b	3e8 <NEXT>

00000294 <STACKSAVE1>:
				
				
				
	STACKSAVE1:	
				
				LDR		R5, =PD_ARRAY
 294:	e59f525c 	ldr	r5, [pc, #604]	; 4f8 <__cs3_region_init_size_ram+0x28>
				STR		R8, [R5, #64]					// STORES CPSR OF PROGR	
 298:	e5858040 	str	r8, [r5, #64]	; 0x40
				STR		R0, [R5]						// STORES R0-R3 of PROGRAM
 29c:	e5850000 	str	r0, [r5]
				STR		R1, [R5, #4]
 2a0:	e5851004 	str	r1, [r5, #4]
				STR		R2, [R5, #8]
 2a4:	e5852008 	str	r2, [r5, #8]
				STR		R3, [R5, #12]
 2a8:	e585300c 	str	r3, [r5, #12]
				
				MOV 	R0, R5							// NOW SINCE WE USED R4, AND R5, R8 WE GOTTA RESTORE IT FROM STACK
 2ac:	e1a00005 	mov	r0, r5
				LDR		R4, [sp, #0]					// 
 2b0:	e59d4000 	ldr	r4, [sp]
				LDR		R5, [sp, #4]
 2b4:	e59d5004 	ldr	r5, [sp, #4]
				LDR		R8, [sp, #8]
 2b8:	e59d8008 	ldr	r8, [sp, #8]
				ADD		sp, sp, #12
 2bc:	e28dd00c 	add	sp, sp, #12
				
				STR		R4, [R0, #16]					//CONTINUE WITH STORING
 2c0:	e5804010 	str	r4, [r0, #16]
				STR		R5, [R0, #20]
 2c4:	e5805014 	str	r5, [r0, #20]
				STR		R6, [R0, #24]
 2c8:	e5806018 	str	r6, [r0, #24]
				STR		R7, [R0, #28]
 2cc:	e580701c 	str	r7, [r0, #28]
				STR		R8, [R0, #32]
 2d0:	e5808020 	str	r8, [r0, #32]
				STR		R9, [R0, #36]
 2d4:	e5809024 	str	r9, [r0, #36]	; 0x24
				STR		R10, [R5, #40]
 2d8:	e585a028 	str	r10, [r5, #40]	; 0x28
				STR		R11, [R0, #44]
 2dc:	e580b02c 	str	r11, [r0, #44]	; 0x2c
				STR		R12, [R0, #48]
 2e0:	e580c030 	str	r12, [r0, #48]	; 0x30
				STR		R13, [R0, #52]
 2e4:	e580d034 	str	sp, [r0, #52]	; 0x34
				STR		R14, [R0, #56]
 2e8:	e580e038 	str	lr, [r0, #56]	; 0x38
				STR		R15, [R0, #60]
 2ec:	e580f03c 	str	pc, [r0, #60]	; 0x3c
				
				B		IRQ1
 2f0:	eaffffdb 	b	264 <IRQ1>

000002f4 <LOADREG1>:
				
	LOADREG1:
	
				LDR		R0, =PD_ARRAY
 2f4:	e59f01fc 	ldr	r0, [pc, #508]	; 4f8 <__cs3_region_init_size_ram+0x28>
				LDR 	R1, [R0, #72]					//LOAD UP PID"S STUFF
 2f8:	e5901048 	ldr	r1, [r0, #72]	; 0x48
				LDR 	R2, [R0, #76]
 2fc:	e590204c 	ldr	r2, [r0, #76]	; 0x4c
				LDR 	R3, [R0, #80]
 300:	e5903050 	ldr	r3, [r0, #80]	; 0x50
				LDR 	R4, [R0, #84]
 304:	e5904054 	ldr	r4, [r0, #84]	; 0x54
				LDR 	R5, [R0, #88]
 308:	e5905058 	ldr	r5, [r0, #88]	; 0x58
				LDR 	R6, [R0, #92]
 30c:	e590605c 	ldr	r6, [r0, #92]	; 0x5c
				LDR 	R7, [R0, #96]
 310:	e5907060 	ldr	r7, [r0, #96]	; 0x60
				LDR 	R8, [R0, #100]
 314:	e5908064 	ldr	r8, [r0, #100]	; 0x64
				LDR 	R9, [R0, #104]
 318:	e5909068 	ldr	r9, [r0, #104]	; 0x68
				LDR 	R10, [R0, #108]
 31c:	e590a06c 	ldr	r10, [r0, #108]	; 0x6c
				LDR 	R11, [R0, #112]
 320:	e590b070 	ldr	r11, [r0, #112]	; 0x70
				LDR 	R12, [R0, #116]
 324:	e590c074 	ldr	r12, [r0, #116]	; 0x74
				LDR 	R13, [R0, #120]
 328:	e590d078 	ldr	sp, [r0, #120]	; 0x78
				LDR 	R14, [R0, #124]
 32c:	e590e07c 	ldr	lr, [r0, #124]	; 0x7c
				
				LDR		R0, [R0, #132]
 330:	e5900084 	ldr	r0, [r0, #132]	; 0x84
				MSR 	SPSR, R0
 334:	e169f000 	msr	SPSR_fc, r0
				SUBS	PC, LR, #4	
 338:	e25ef004 	subs	pc, lr, #4

0000033c <STACKSAVE2>:
				
	STACKSAVE2:	
				
				LDR		R5, =PD_ARRAY
 33c:	e59f51b4 	ldr	r5, [pc, #436]	; 4f8 <__cs3_region_init_size_ram+0x28>
				ADD		R5, R5, #68
 340:	e2855044 	add	r5, r5, #68	; 0x44
				STR		R8, [R5, #64]					// STORES CPSR OF PROGR	
 344:	e5858040 	str	r8, [r5, #64]	; 0x40
				STR		R0, [R5]						// STORES R0-R3 of PROGRAM
 348:	e5850000 	str	r0, [r5]
				STR		R1, [R5, #4]
 34c:	e5851004 	str	r1, [r5, #4]
				STR		R2, [R5, #8]
 350:	e5852008 	str	r2, [r5, #8]
				STR		R3, [R5, #12]
 354:	e585300c 	str	r3, [r5, #12]
				
				MOV 	R0, R5							// NOW SINCE WE USED R4, AND R5, R8 WE GOTTA RESTORE IT FROM STACK
 358:	e1a00005 	mov	r0, r5
				LDR		R4, [sp, #0]					// 
 35c:	e59d4000 	ldr	r4, [sp]
				LDR		R5, [sp, #4]
 360:	e59d5004 	ldr	r5, [sp, #4]
				LDR		R8, [sp, #8]
 364:	e59d8008 	ldr	r8, [sp, #8]
				ADD		sp, sp, #12
 368:	e28dd00c 	add	sp, sp, #12
				
				STR		R4, [R0, #16]					//CONTINUE WITH STORING
 36c:	e5804010 	str	r4, [r0, #16]
				STR		R5, [R0, #20]
 370:	e5805014 	str	r5, [r0, #20]
				STR		R6, [R0, #24]
 374:	e5806018 	str	r6, [r0, #24]
				STR		R7, [R0, #28]
 378:	e580701c 	str	r7, [r0, #28]
				STR		R8, [R0, #32]
 37c:	e5808020 	str	r8, [r0, #32]
				STR		R9, [R0, #36]
 380:	e5809024 	str	r9, [r0, #36]	; 0x24
				STR		R10, [R5, #40]
 384:	e585a028 	str	r10, [r5, #40]	; 0x28
				STR		R11, [R0, #44]
 388:	e580b02c 	str	r11, [r0, #44]	; 0x2c
				STR		R12, [R0, #48]
 38c:	e580c030 	str	r12, [r0, #48]	; 0x30
				STR		R13, [R0, #52]
 390:	e580d034 	str	sp, [r0, #52]	; 0x34
				STR		R14, [R0, #56]
 394:	e580e038 	str	lr, [r0, #56]	; 0x38
				STR		R15, [R0, #60]
 398:	e580f03c 	str	pc, [r0, #60]	; 0x3c
				
				B		IRQ2
 39c:	eaffffb7 	b	280 <IRQ2>

000003a0 <LOADREG2>:
				
	LOADREG2:
	
				LDR		R0, =PD_ARRAY
 3a0:	e59f0150 	ldr	r0, [pc, #336]	; 4f8 <__cs3_region_init_size_ram+0x28>
				LDR 	R1, [R0, #4]					//LOAD UP PID"S STUFF
 3a4:	e5901004 	ldr	r1, [r0, #4]
				LDR 	R2, [R0, #8]
 3a8:	e5902008 	ldr	r2, [r0, #8]
				LDR 	R3, [R0, #12]
 3ac:	e590300c 	ldr	r3, [r0, #12]
				LDR 	R4, [R0, #16]
 3b0:	e5904010 	ldr	r4, [r0, #16]
				LDR 	R5, [R0, #20]
 3b4:	e5905014 	ldr	r5, [r0, #20]
				LDR 	R6, [R0, #24]
 3b8:	e5906018 	ldr	r6, [r0, #24]
				LDR 	R7, [R0, #28]
 3bc:	e590701c 	ldr	r7, [r0, #28]
				LDR 	R8, [R0, #32]
 3c0:	e5908020 	ldr	r8, [r0, #32]
				LDR 	R9, [R0, #36]
 3c4:	e5909024 	ldr	r9, [r0, #36]	; 0x24
				LDR 	R10, [R0, #40]
 3c8:	e590a028 	ldr	r10, [r0, #40]	; 0x28
				LDR 	R11, [R0, #44]
 3cc:	e590b02c 	ldr	r11, [r0, #44]	; 0x2c
				LDR 	R12, [R0, #48]
 3d0:	e590c030 	ldr	r12, [r0, #48]	; 0x30
				LDR 	R13, [R0, #52]
 3d4:	e590d034 	ldr	sp, [r0, #52]	; 0x34
				LDR 	R14, [R0, #56]
 3d8:	e590e038 	ldr	lr, [r0, #56]	; 0x38
				
				LDR		R0, [R0, #64]
 3dc:	e5900040 	ldr	r0, [r0, #64]	; 0x40
				MSR 	SPSR, R0
 3e0:	e169f000 	msr	SPSR_fc, r0
				SUBS	PC, LR, #4	
 3e4:	e25ef004 	subs	pc, lr, #4

000003e8 <NEXT>:
		NEXT:
		
				/*PART 3 INTERUPT FROM JTAG UART -----------------------------*/
				/* This code is taken from the Altera University Program DE1-SoC on pg16 and modified*/
				
				LDR 	R8, =0xFFFEC100 	//Interuprt controller's base addr
 3e8:	e59f8100 	ldr	r8, [pc, #256]	; 4f0 <__cs3_region_init_size_ram+0x20>
				LDR 	R5, [R8,#0xC]		//Determine source of interupt
 3ec:	e598500c 	ldr	r5, [r8, #12]
				CMP		R5, #80				//IS IT JTAG UART? IF NOT THEN LEL YOU GO NEXT0 (TO THE NEXT INTERUPT (TIMER))
 3f0:	e3550050 	cmp	r5, #80	; 0x50
				BNE		NEXT0
 3f4:	1a000006 	bne	414 <FPGA_IRQ1_HANDLER>
				
				LDR		R0, =0xFF201000		//BASE ADDRESS OF YUNGJAYTAG
 3f8:	e59f00d4 	ldr	r0, [pc, #212]	; 4d4 <__cs3_region_init_size_ram+0x4>
				LDR		R1, [R0] 			// read the JTAG UART data register
 3fc:	e5901000 	ldr	r1, [r0]
				LDR		R8, =CHAR_BUFFER
 400:	e59f80d4 	ldr	r8, [pc, #212]	; 4dc <__cs3_region_init_size_ram+0xc>
				STR		R1, [R8]
 404:	e5881000 	str	r1, [r8]
				LDR		R8, =CHAR_FLAG
 408:	e59f80c8 	ldr	r8, [pc, #200]	; 4d8 <__cs3_region_init_size_ram+0x8>
				MOV		R2, #1
 40c:	e3a02001 	mov	r2, #1
				STR		R2, [R8]
 410:	e5882000 	str	r2, [r8]

00000414 <FPGA_IRQ1_HANDLER>:
				
		NEXT0:

FPGA_IRQ1_HANDLER:
    			CMP		R5, #KEYS_IRQ
 414:	e3550049 	cmp	r5, #73	; 0x49
				BNE		NEXT1    					// if not recognized, stop here
 418:	1a000001 	bne	424 <NEXT1>
    
    			BL			KEY_ISR
 41c:	ebffff30 	bl	e4 <KEY_ISR>

00000420 <EXIT_IRQ>:
EXIT_IRQ:
    			/* Write to the End of Interrupt Register (ICCEOIR) */
    			STR		R5, [R4, #ICCEOIR]			// write to ICCEOIR
 420:	e5845010 	str	r5, [r4, #16]

00000424 <NEXT1>:
				
		NEXT1:
    
    			POP		{R0-R7, LR}
 424:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    			SUBS		PC, LR, #4
 428:	e25ef004 	subs	pc, lr, #4

0000042c <SERVICE_FIQ>:

/*--- FIQ ---------------------------------------------------------------------*/
SERVICE_FIQ:
    			B			SERVICE_FIQ 
 42c:	eafffffe 	b	42c <SERVICE_FIQ>

00000430 <counter>:
 430:	00000000 	.word	0x00000000

00000434 <CHAR_BUFFER>:
 434:	00000000 	.word	0x00000000

00000438 <CHAR_FLAG>:
 438:	00000000 	.word	0x00000000

0000043c <CURRENT_PID>:
 43c:	00000000 	.word	0x00000000

00000440 <PD_ARRAY>:
 440:	deadbeef 	.word	0xdeadbeef
 444:	deadbeef 	.word	0xdeadbeef
 448:	deadbeef 	.word	0xdeadbeef
 44c:	deadbeef 	.word	0xdeadbeef
 450:	deadbeef 	.word	0xdeadbeef
 454:	deadbeef 	.word	0xdeadbeef
 458:	deadbeef 	.word	0xdeadbeef
 45c:	deadbeef 	.word	0xdeadbeef
 460:	deadbeef 	.word	0xdeadbeef
 464:	deadbeef 	.word	0xdeadbeef
 468:	deadbeef 	.word	0xdeadbeef
 46c:	deadbeef 	.word	0xdeadbeef
 470:	deadbeef 	.word	0xdeadbeef
 474:	deadbeef 	.word	0xdeadbeef
 478:	deadbeef 	.word	0xdeadbeef
 47c:	deadbeef 	.word	0xdeadbeef
 480:	deadbeef 	.word	0xdeadbeef
 484:	deadbee1 	.word	0xdeadbee1
 488:	deadbee1 	.word	0xdeadbee1
 48c:	deadbee1 	.word	0xdeadbee1
 490:	deadbee1 	.word	0xdeadbee1
 494:	deadbee1 	.word	0xdeadbee1
 498:	deadbee1 	.word	0xdeadbee1
 49c:	deadbee1 	.word	0xdeadbee1
 4a0:	deadbee1 	.word	0xdeadbee1
 4a4:	deadbee1 	.word	0xdeadbee1
 4a8:	deadbee1 	.word	0xdeadbee1
 4ac:	deadbee1 	.word	0xdeadbee1
 4b0:	deadbee1 	.word	0xdeadbee1
 4b4:	deadbee1 	.word	0xdeadbee1
 4b8:	3f000000 	.word	0x3f000000
 4bc:	00000000 	.word	0x00000000
 4c0:	000001e0 	.word	0x000001e0
 4c4:	00000053 	.word	0x00000053
 4c8:	ff200050 	.word	0xff200050
 4cc:	fffec600 	.word	0xfffec600
 4d0:	05f5e100 	.word	0x05f5e100
 4d4:	ff201000 	.word	0xff201000
 4d8:	00000438 	.word	0x00000438
 4dc:	00000434 	.word	0x00000434
 4e0:	0000ffff 	.word	0x0000ffff
 4e4:	00000430 	.word	0x00000430
 4e8:	ff200000 	.word	0xff200000
 4ec:	17d78400 	.word	0x17d78400
 4f0:	fffec100 	.word	0xfffec100
 4f4:	0000043c 	.word	0x0000043c
 4f8:	00000440 	.word	0x00000440
